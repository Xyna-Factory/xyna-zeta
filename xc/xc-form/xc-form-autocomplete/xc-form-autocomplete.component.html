<mat-form-field [floatLabel]="floatLabel" hideRequiredMarker>
  <mat-label>{{label}}</mat-label>
    <ng-container *ngIf="multiSelect; else singleSelect">
      <!-- This input displays selected values and opens the mat-select -->
      <input matInput [placeholder]="placeholder" [value]="getMultiSelectedNames()" readonly
        (focus)="multiSelectDropdown.open()" (click)="onFieldClick($event)" [attr.aria-label]="ariaLabel"
        [tabIndex]="(readonly || disabled) ? -1 : 0" class="multiselect-input" />
      <!-- Hidden actual select, still functional -->
      <mat-select #multiSelectDropdown [formControl]="multiSelectControl" multiple
        (openedChange)="onMultiSelectOpened($event)" [panelClass]="'multiselect-panel'" class="hidden-field">
        <mat-option *ngFor="let option of filteredMultiSelectOptions" [value]="option.value" [xc-tooltip]=option.name
          [xc-tooltip-position]="['bottom-right', 'bottom-left', 'top-right', 'top-left']">
          {{ option.name }}
        </mat-option>

      <div mat-select-footer class="multiselect-actions fbany fbrow justify-end gap">
        <xc-button (click)="cancelMultiSelect()" xc-i18n [attr.aria-label]="'cancel' | xcI18n">cancel</xc-button>
        <xc-button (click)="applyMultiSelect()" xc-i18n [attr.aria-label]="'apply' | xcI18n">apply</xc-button>
      </div>
    </mat-select>
  </ng-container>
  <ng-template #singleSelect>
    <input matInput autocomplete="off" [type]="type" [placeholder]="placeholder" [formControl]="formControl"
      [matAutocomplete]="auto" (mousedown)="mousedown($event)" (focus)="onfocus($event)" (blur)="onblur($event)"
      [readonly]="readonly" [attr.aria-label]="ariaLabel" [tabIndex]="(readonly || disabled) ? -1 : tabIndex"
      [required]="required">
    <!-- <ng-container *ngIf="readonly || disabled">
    <input
      [type]="type"
      [value]="stringValue"
      [attr.tabIndex]="readonly ? 0 : -1"
      [attr.aria-label]="ariaLabel"
      (focus)="focus.emit($event)"
      (blur)="blur.emit($event)"
      [readonly]="readonly"
      [disabled]="disabled"
      class="non-editable-input"
      >
    </ng-container> -->
  <!-- screen reader (like JAWS) read fields, which are attributed with 'aria-live', aloud when their value changes -->
  <!-- this hidden-field is a fall-back to insure that screenreader read the currently active (!= selected) field aloud -->
  <div class="hidden-field" aria-live="polite" role="none">{{activeOption ? activeOption.name : ''}}</div>
  <mat-autocomplete class="zeta-scrollbar" #auto="matAutocomplete" (optionSelected)="optionSelected($event.option)"
    [displayWith]="optionName" (opened)="openedAutocomplete()" (closed)="closedAutocomplete()">
    @for (option of filteredOptions | async; let i = $index; track i) {
    <mat-option tabindex="0" [value]="option" [disabled]="option.disabled || readonly"
      [xc-tooltip]="option.showTooltip ? option.name : ''"
      [xc-tooltip-position]="['bottom-right', 'bottom-left', 'top-right', 'top-left']">
      @if (option.icon) {
      <xc-icon [xc-icon-name]="option.icon" xc-icon-size="small">{{option.name}}</xc-icon>
      } @else {
      {{option.name}}
      }
    </mat-option>
    }
  </mat-autocomplete>
</ng-template>
  @if (errorVisible) {
  <mat-error align="end">{{errorContent}}</mat-error>
  }

  @if (suffixVisible && !readonly) {
  <button type="button" mat-icon-button matSuffix (mousedown)="suffixMouseDown($event)" (click)="suffixClick($event)"
    [tabIndex]="(readonly || disabled) ? -1 : tabIndexSuffix" [attr.aria-label]="iconTooltip || suffixContent"
    xc-tooltip="{{iconTooltip || (suffixContent | xcI18n)}}" [disabled]="readonly || disabled">
    <mat-icon>{{suffixContent}}</mat-icon>
  </button>
  }
</mat-form-field>